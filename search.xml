<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ModbusTCP详解</title>
      <link href="posts/613601ea.html"/>
      <url>posts/613601ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;Modbus 是由美国MODICON公司于1979年开发,是一种工业现场总线协议标准。1997年施耐德公司推出给予以太网TCP/IP的modbus协议————ModbusTCP.</p><h1 id="ModubsTCP数据帧"><a href="#ModubsTCP数据帧" class="headerlink" title="ModubsTCP数据帧"></a>ModubsTCP数据帧</h1><p>&emsp;&emsp;ModbusTCP的数据帧可以分为两部分：MBAP + PDU.<br>&emsp;&emsp;(Modbus Application Protocol——报文头)<br>&emsp;&emsp;(Protocol Data Unit——协议数据单元)  </p><p><strong>特别说明：在ModbusTCP中，由从站作服务端，主站作客户端，保证主动权在主站手中</strong></p><h2 id="报文头MBAP"><a href="#报文头MBAP" class="headerlink" title="报文头MBAP"></a>报文头MBAP</h2><p>&emsp;&emsp;MBAP为报文头，长度为7字节，组成如下：  </p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210714142522.png"><br>&emsp;&emsp;<strong>事物处理标识</strong>：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文。<br>&emsp;&emsp;<strong>协议标识符</strong>  ：00 00 表示ModbusTCP协议。<br>&emsp;&emsp;<strong>长度</strong>：表示接下来的数据长度，单位为字节。<br>&emsp;&emsp;<strong>单元标识符</strong>：可以理解为设备地址。<br>&emsp;&emsp;其中以上四项中，对 <strong>长度</strong> 做额外举例如下:<br>&emsp;&emsp;&emsp;&emsp;<u>00 01 00 00 <font color=red>00 06</font> 01</u> 03 00 00 00 03<br>&emsp;&emsp;上面是一条读取保持寄存器的指令，划横线部份是MBAP。红色字体为长度数据，表示从当前之后的数据总长度。<br>（注:并不是指PDU的数据长度）</p><h2 id="帧结构PDU"><a href="#帧结构PDU" class="headerlink" title="帧结构PDU"></a>帧结构PDU</h2><p>&emsp;&emsp;PUD由 <strong>功能码</strong> + <strong>数据</strong> 组成。功能码为1字节，数据长度不定，由具体功能决定。</p><h3 id="功能码"><a href="#功能码" class="headerlink" title="功能码"></a>功能码</h3><p>&emsp;&emsp;modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。  </p><ul><li>  线圈：PLC的输出位，开关量，在modbus中可读可写。（可以理解为可读可惜的bit）</li><li>  离散量：PCL的输入为，开关量，在modbus中只读。（可以理解为只读的bit）</li><li>  输入寄存器：PLC中只能从模拟量输入端改变的寄存器，在modbus中只读。（可以理解为只读寄存器，一个寄存器占用2个字节）</li><li>  保持寄存器：PLC中用于输出模拟量信号的寄存器，在modbus中可读可写。（可以理解为可读写寄存器，一个寄存器占用2个字节）</li></ul><p>根据操作对象/操作内容不同，modbus功能码分为以下几种：</p><ul><li>  0x01：读线圈</li><li>  0x05：写单个线圈</li><li>  0x0F：写多个线圈</li><li>  0x02：读离散量</li><li>  0x04：读输入寄存器</li><li>  0x03：读保持寄存器</li><li>  0x06：写单个保持寄存器</li><li>  0x10：写多个保持寄存器</li></ul><h3 id="PDU详细结构"><a href="#PDU详细结构" class="headerlink" title="PDU详细结构"></a>PDU详细结构</h3><p>（根据不同功能码，PDU的结构有所变化）<br><strong>0x01：读线圈</strong><br>在从站中读取1~8个连续线圈状态，其中ON=1，OFF=0</p><ul><li><p>请求数据：MBAP + 功能码 + 起始地址H(高8位) + 起始地址L(低8位) + 数量H(高8位) + 数量L(低8位)</p></li><li><p>如： 在从站0x01中，读取开始地址为0x0001的线圈数据，读0x0008位<br>&emsp;&emsp;       00 01                  00 00              00 06             01               01                  00 01             00 08</p><p>​      (事务处理标识)     （协议标识）    （长度）（设备标识）（功能码）   （起始地址） （读取数量）</p></li><li><p>响应数据：MBAP + 功能码 + 数据长度 + 数据</p></li><li><p>如： 数据长度为0x01字节（8位），数据值为0x03,第一个和第二个线圈为ON，其余为OFF<br>&emsp;&emsp;00 01                       00 00          00 04            01                   01                  03</p><p>   (事务处理标识)     （协议标识） （长度）（设备标识）（数据长度）   （数据值） </p></li></ul><p><strong>0x05：写单个线圈</strong><br>将从站中的一个输出写成ON或OFF，<strong>0xFF00</strong>表示将目标位写为ON,<strong>0x0000</strong>表示将目标位写为OFF</p><ul><li>  请求数据：MBAP + 功能码 + 目标地址H(高8位) + 目标地址L(低8位) + 数据值H(高8位) + 数据值L(低8位)</li><li>  如： 在从站0x01中，将地址为0x0001的线圈数据设置为ON<br>&emsp;&emsp;00 01 00 00 00 06 01 05 00 01 FF 00</li><li>  响应数据：MBAP + 功能码 + 目标地址H(高8位) + 目标地址L(低8位) + 数据值H(高8位) + 数据值L(低8位)</li><li>  如： 写入成功<br>&emsp;&emsp;00 01 00 00 00 06 01 05 00 01 FF 00  </li></ul><p><strong>0x0F：写多个线圈</strong><br>将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF</p><ul><li>  请求数据：MBAP + 功能码 + 起始地址H(高8位) + 起始地址L(低8位) + 写数量H(高8位) + 写数量L(低8位) + 输出值H(高8位) + 输出值L(低8位)</li><li>  如： 在从站0x01中，将地址为0x0001~0X008的线圈数据设置为ON<br>&emsp;&emsp;00 01 00 00 00 08 01 0F 00 01 00 08 00 FF</li><li>  响应数据：MBAP + 功能码 + 起始地址H(高8位) + 起始地址L(低8位) + 写数量H(高8位) + 写数量L(低8位)</li><li>  如： 写入成功<br>&emsp;&emsp;00 01 00 00 00 06 01 0F 00 01 00 08</li></ul><p><strong>0x02：读离散量输入</strong><br>从一个从站中读1~15个连续的离散量输入状态</p><ul><li>  请求数据：MBAP + 功能码 + 起始地址H(高8位) + 起始地址L(低8位) + 读数量H(高8位) + 读数量L(低8位) </li><li>  如： 从地址0x0001开始读15个离散量输入<br>&emsp;&emsp;00 01 00 00 00 06 01 02 00 01 00 0F</li><li>  响应数据：MBAP + 功能码 + 数据长度 + 数据</li><li>  如： 读取成功，数据长度为0x02, 数据为0x05 0x01 ，表示第1个、第9个、第11个离散量的值为ON，其余为OFF<br>&emsp;&emsp;00 01 00 00 00 05 01 02 02 05 01</li></ul><p><strong>0x04：读输入寄存器</strong><br>从一个远程设备中读1~5个连续输入寄存器</p><ul><li>  请求数据：MBAP + 功能码 + 起始地址H(高8位) + 起始地址L(低8位) + 寄存器数量H(高8位) + 寄存器数量L(低8位) </li><li>  如： 从地址0x0001开始读5个输入寄存器<br>&emsp;&emsp;00 01 00 00 00 06 01 04 00 01 00 05</li><li>  响应数据：MBAP + 功能码 + 数据长度 + 寄存器数据</li><li>  如： 读取成功，数据长度为0x0A, 第1个数据为0x00A0, 第2个数据为0xFF00 第3个数据为0x4C4C 第4个数据为0x0000 第5个数据为0xAAAA<br>&emsp;&emsp;00 01 00 00 00 0D 01 04 0A 00 A0 FF 00 4C 4C 00 00 AA AA</li></ul><p><strong>0x03：读保持寄存器</strong><br>从一个远程设备中读1~3个连续保持寄存器</p><ul><li>  请求数据：MBAP + 功能码 + 起始地址H(高8位) + 起始地址L(低8位) + 寄存器数量H(高8位) + 寄存器数量L(低8位) </li><li>  如： 从地址0x0001开始读5个输入寄存器<br>&emsp;&emsp;00 01 00 00 00 06 01 03 00 01 00 03</li><li>  响应数据：MBAP + 功能码 + 数据长度 + 寄存器数据</li><li>  如： 读取成功，数据长度为0x06, 第1个数据为0x00A0, 第2个数据为0x0000 第3个数据为0xAAAA<br>&emsp;&emsp;00 01 00 00 00 09 01 03 06 00 A0 00 00 AA AA</li></ul><p><strong>0x06：写单个保持寄存器</strong><br>在一个远程设备中写1个保持寄存器</p><ul><li>  请求数据：MBAP + 功能码 + 寄存器地址H(高8位) + 寄存器地址L(低8位) + 寄存器值H(高8位) + 寄存器值L(低8位) </li><li>  如： 在地址0x0001写入0x00FF<br>&emsp;&emsp;00 01 00 00 00 06 01 06 00 01 00 FF</li><li>  响应数据：MBAP + 功能码 + 寄存器地址H(高8位) + 寄存器地址L(低8位) + 寄存器值H(高8位) + 寄存器值L(低8位) </li><li>  如： 写入成功<br>&emsp;&emsp;00 01 00 00 00 06 01 06 00 01 00 FF  </li></ul><p><strong>0x10：写多个保持寄存器</strong><br>在一个远程设备中写连续3个保持寄存器</p><ul><li>  请求数据：MBAP + 功能码 + 寄存器起始地址H(高8位) + 寄存器起始地址H(低8位) + 寄存器数量H(高8位) + 寄存器数量L(低8位) + 字节长度 + 寄存器值 </li><li>  如： 从地址0x0001开始写入3个保持寄存器值，0x00FF，0xFF00, 0xF0F0<br>&emsp;&emsp;00 01 00 00 00 0D 01 10 00 01 00 03 06 00 FF FF 00 F0 F0</li><li>  响应数据：MBAP + 功能码 + 寄存器起始地址H(高8位) + 寄存器起始地址H(低8位) + 寄存器数量H(高8位) + 寄存器数量L(低8位) </li><li>  如： 写入成功<br>&emsp;&emsp;00 01 00 00 00 06 01 10 00 01 00 03</li></ul><h1 id="ModbusTCP通信"><a href="#ModbusTCP通信" class="headerlink" title="ModbusTCP通信"></a>ModbusTCP通信</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>&emsp;&emsp;modbus设备可分为主站（poll）和从站（slave）。主站只有一个，从站有多个，主站向各从站发送请求帧，从站给予相应。在使用TCP通信时，主站为客户端（client），主动建立连接；从站为服务端（server），等待连接。</p><ul><li>  主站请求：功能码+数据</li><li>  从站正常响应：请求功能码+响应数据</li><li>  从站异常响应：异常功能码+异常码，其中异常功能码即将请求功能码的最高有效位置1，异常码指示差错类型</li><li>  注意：需要超时管理机制，避免无期限的等待可能不出现的应答  </li></ul><h2 id="异常码"><a href="#异常码" class="headerlink" title="异常码"></a>异常码</h2><p>异常功能码即将请求功能码的最高有效位置1</p><ul><li>01：非法功能<br>  &emsp;&emsp;对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。<br>  <br/><br/> </li><li>02：非法数据地址<br>  &emsp;&emsp;对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。<br>  <br/><br/> </li><li>03：非法数据值<br>  &emsp;&emsp;对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。<br>  <br/><br/> </li><li>04：从站设备故障<br>  &emsp;&emsp;当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。<br>  <br/><br/> </li><li>05：确认<br>  &emsp;&emsp;与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。<br>   <br/><br/>  </li><li>07：从属设备忙<br>  &emsp;&emsp;与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。<br>  <br/><br/>  </li><li>08：存储奇偶性差错<br>  &emsp;&emsp;与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。<br>  <br/><br/> </li><li>0A：不可用网关路径<br>  &emsp;&emsp;与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。<br>  <br/><br/> </li><li>0B：网关目标设备响应失败<br>  &emsp;&emsp;与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。</li></ul><p>参考资料：<br><a href="https://wenku.baidu.com/view/c2a9e1cc376baf1ffd4fad5c.html">https://wenku.baidu.com/view/c2a9e1cc376baf1ffd4fad5c.html</a><br><a href="https://blog.csdn.net/zwxue251/article/details/24154951">https://blog.csdn.net/zwxue251/article/details/24154951</a><br><a href="https://blog.csdn.net/lakerszhy/article/details/68927178?locationNum=4&amp;fps=1">https://blog.csdn.net/lakerszhy/article/details/68927178?locationNum=4&amp;fps=1</a><br><a href="https://blog.csdn.net/iknow_nothing/article/details/84292914">https://blog.csdn.net/iknow_nothing/article/details/84292914</a><br><a href="http://blog.sina.com.cn/s/blog_91a077e50101ina9.html">http://blog.sina.com.cn/s/blog_91a077e50101ina9.html</a><br><a href="https://blog.csdn.net/lushoumin/article/details/89073556">https://blog.csdn.net/lushoumin/article/details/89073556</a></p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工业 </tag>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT编译过程中的一些错误处理</title>
      <link href="posts/2031f6c8.html"/>
      <url>posts/2031f6c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="QT编译过程中的一些错误处理"><a href="#QT编译过程中的一些错误处理" class="headerlink" title="QT编译过程中的一些错误处理"></a>QT编译过程中的一些错误处理</h1><h2 id="1、undefined-reference-to-vtable-for-GoToCellDialog’"><a href="#1、undefined-reference-to-vtable-for-GoToCellDialog’" class="headerlink" title="1、undefined reference to `vtable for GoToCellDialog’"></a>1、undefined reference to `vtable for GoToCellDialog’</h2><p>&emsp;造成这个错误的原因可能是编写继承自QObject类及其子类的自定义类的时候，忘记加入Q_OBJECT宏，编译或者运行报错后手动添加了Q_OBJECT再次编译引起的。</p><h6 id="emsp-解决方案："><a href="#emsp-解决方案：" class="headerlink" title="&emsp;解决方案："></a>&emsp;解决方案：</h6><p> &emsp;&emsp;手动删除xxx.pro.user文件，clean项目，重新编译即可。</p><h2 id="2、Object-connect-No-such-slot-xxxx"><a href="#2、Object-connect-No-such-slot-xxxx" class="headerlink" title="2、Object::connect: No such slot xxxx"></a>2、Object::connect: No such slot xxxx</h2><h6 id="emsp-解决方案：-1"><a href="#emsp-解决方案：-1" class="headerlink" title="&emsp;解决方案："></a>&emsp;解决方案：</h6><p>  &emsp;&emsp;①查看类声明中有没有Q_OBJECT </p><p>  &emsp;&emsp;②声明的函数要加声明: </p><blockquote><p>&emsp;&emsp;private slots:<br>&emsp;&emsp;&emsp;void xxxx();</p></blockquote><p>&emsp;&emsp;③检查槽函数名拼写是否有误，以及对应的signal和slot的参数是否一致  </p><p>…未完待续，持续更新中…</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的hexo个人博客搭建过程</title>
      <link href="posts/9a1e054d.html"/>
      <url>posts/9a1e054d.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp; 时隔2年，又一次重新搭建了博客。折腾了大半个月，原本只是想找一份以前写的文章测试一下文章的格式，翻遍了有道笔记，愣是没找到一篇稍微能看的下去的，此时心情之复杂，难以言喻。总之测试还是要做的，就记录一下搭建hexo博客的过程,顺便复习一下markdown语法。<br>&emsp; hexo框架是一位朋友推荐给我的，之前的博客用的也是这个框架，总而言之想要用hexo搭建个人博客的确是非常方便。</p><hr><h2 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h2><ul><li><strong>1.1、安装node.js</strong></li></ul><p>​&emsp;​&emsp; 安装版本推荐12，貌似node.js-v14和hexo有部分内容不兼容，使用的时候会有警告，为了避免后续使用出现问题，还是提早就使用12版本的好，下载地址如下：</p><p>​&emsp;​​&emsp;​​&emsp;​<a href="https://nodejs.org/zh-cn/download/releases/">node.js历史版本</a></p><ul><li><p><strong>1.2、安装git</strong></p></li><li><p><strong>1.3、安装windows powershell(linux用户可直接跳过这一步)</strong></p><p>详细安装过程建议参考以下链接</p></li></ul><p>​&emsp;​​&emsp;​​&emsp;​<a href="https://zhuanlan.zhihu.com/p/137595941">Windows Terminal 完美配置 PowerShell 7.1</a></p><h2 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h2><ul><li><strong>2.1、创建托管仓库</strong></li></ul><p>​&emsp;&emsp;​ 新建一个仓库，名字必须设置为 xxx.github.io，其中xxx为github用户名。比如github用户名为clock,那么仓库名称即为clock.github.io，其他名称无法作为博客托管仓库。（这里发现一个彩蛋，如果新建的仓库名为xxx.github时——xxx为用户名，该仓库会作为你的github主页展示）。</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130113804.png"></p><ul><li><strong>2.2、绑定个人域名</strong></li></ul><p>​&emsp;​&emsp; 不打算绑定个人域名or不打算申请个人域名的请直接跳过。</p><p>​&emsp;​&emsp; 首先需要一个域名，可以选择阿里云、腾讯云等等，反正哪里性价比高选哪里。有了域名之后，进入xxx.github.io仓库，点击setting。</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130080118.png"></p><p>​&emsp;​&emsp; 在GitHub Pages 中设置你自己的域名</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/image-20210130080345436.png"></p><p>​&emsp;​&emsp; 其中Custom domain 中填入域名，点击save之后，若解析正确，在上方会显示“Your site is published at xxxxxx”，如上图另一个框所示。</p><ul><li><strong>2.3、配置SSH key</strong></li></ul><p>​&emsp;​&emsp; 执行如下命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t ras -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>​&emsp;​&emsp; 如图所示</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130114024.png"></p><p>​&emsp;​&emsp; 出现如图字样，说明安装成功，再连续回车3次即可。安装成功会显示密钥路径，根据路径找到文件，打开<code>id_rsa.pub</code>文件，将其内容全部复制。</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130114040.png"></p><p>​&emsp;​&emsp;打开github网站，点击设置，如图。粘贴上一步复制的内容到Key位置，Title随便输入。</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130114115.png"></p><p>​&emsp;​&emsp;输入</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure><p>  ​&emsp;​&emsp;出现下图表示配置成功。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> Hi jiangnan1q! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span></span><br></pre></td></tr></table></figure><p>  ​&emsp;​&emsp;如图所示</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130114330.png"></p><h2 id="hexo安装及部署"><a href="#hexo安装及部署" class="headerlink" title="hexo安装及部署"></a>hexo安装及部署</h2><ul><li><strong>3.1、hexo 安装</strong></li></ul><p>​&emsp;​&emsp;打开powershell，输入命令 <code>npm install -g hexo-cli</code> </p><ul><li><strong>3.2、初始化hexo</strong></li></ul><p>​&emsp;​&emsp;在你想要安装hexo的位置新建一个空文件夹，在powershell中进入该目录，输入命令 ```hexo init`` ，初始化成功如下图：</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210201144145.png"></p><p>​&emsp;​&emsp;目录结构如图所示：<br><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/image-20210201144230359.png"></p><ul><li><strong>3.3、测试hexo</strong></li></ul><p>​&emsp;​&emsp;使用以下命令启动hexo：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>​&emsp;​&emsp;打开浏览器，输入localhost:4000，查看hexo是否成功初始化。</p><p>​&emsp;​&emsp;初始化的界面如下所示：</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210201144657.png"></p><ul><li><strong>3.4、hexo部署</strong></li></ul><p>​&emsp;​&emsp;在powershell中依次执行以下命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>​&emsp;​&emsp;打开hexo目录下的_config.yml文件，拉倒最下面，按照图片配置，其中repository是前面新建的xxx.github.io的地址。<br><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/image-20210201150151242.png"></p><p>​&emsp;​&emsp;ps：建议使用能够检查yaml语法的编辑器，避免由于缩进错误引起的语法错误。</p><p>​&emsp;​&emsp;最后使用 <code>hexo d</code> 完成远程部署。</p><ul><li><p><strong>3.5、关于部署与个人域名的注意事项</strong></p><p>由于hexo在部署的时候会将本地的文件同步到远程，而之前 <font color=#0000FF ><strong>2.2、绑定个人域名</strong></font> 时自动生成的CNAME文件会被删除。有以下两种方式：</p><p>​     ①进入hexo根目录下/.deploy_git，输入以下命令</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>​&emsp;​&emsp;​&emsp;等待文件同步完成后，拷贝CNAME文件到hexo根目录/source/下</p><p>​            执行以下命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>​&emsp;​&emsp;​&emsp;​②直接进入hexo根目录下/source/，创建文件CNAME（没有文件格式，使用TXT文本打开进行编辑），输入内容为个人域名，如下图：</p><p><img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/20210130113528.png"></p><p>​&emsp;​&emsp;​&emsp;之后同样执行以下命令即可完成部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​&emsp;最后，放上今天刚获得的表情包。</p><p>   <img src="https://sxxspace.oss-cn-hangzhou.aliyuncs.com/image/Expression-Package-2021-02-01.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/4a17b156.html"/>
      <url>posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
